#pragma once
#include <iostream>

namespace ext
{
    enum class Month
    {
        January = 1,
        February,
        March,
        April,
        May,
        June,
        July,
        August,
        September,
        October,
        Novemver,
        December
    };

    enum class DateFormat
    {
        MonthAsInt,
        MonthAsString
    };

    enum class Season
    {
        Winter,
        Spring,
        Summer,
        Autumn
    };

    enum class SortBy
    {
        Date,
        Season
    };

    struct Date
    {
        int year;
        Month month;
        int day;
    };

    struct TimeDelta
    {
        int delta;
    };

    /*----------homework-04----------*/
    /*
        Âîçâðàùàåò Þëèàíñêóþ äàòó
        https://ru.wikipedia.org/wiki/%D0%AE%D0%BB%D0%B8%D0%B0%D0%BD%D1%81%D0%BA%D0%B0%D1%8F_%D0%B4%D0%B0%D1%82%D0%B0
        ðàçäåë "Âû÷èñëåíèå íîìåðà þëèàíñêîãî äíÿ (JDN) ïî äàòå ãðèãîðèàíñêîãî êàëåíäàðÿ"
        Òåñòîâûå äàííûå					Îæèäàåìûé ðåçóëüòàò
        1.12.2018					2458454
        1.1.2018					2458120
        1.6.2000					2451697
        21.12.2012					2456283
    */
    TimeDelta countJND(Date date) {
        int a, y, m;
        TimeDelta jdn;
        a = (14 - static_cast<int>(date.month)) / 12;
        y = date.year + 4800 - a;
        m = static_cast<int>(date.month) + 12 * a - 3;

        jdn.delta = date.day + ((153 * m + 2) / 5) + 365 * y + y / 4 - y / 100 + y / 400 - 32045;
        return jdn;
    }

    /*
        Ðàññ÷èòûâàåò êîëè÷åñòâî äíåé ìåæäó äâóìÿ äàòàìè.
        Ïðè ðåàëèçâàöèè èñïîëüçóéòå CountJND
    */
    TimeDelta countDistance(Date from, Date to);

    void printMonthAsString(Month month)
    {
        switch (month)
        {
            case Month::January:
                std::cout << "january";
                break;
            case Month::February:
                std::cout << "february";
                break;
            case Month::March:
                std::cout << "march";
                break;
            case Month::April:
                std::cout << "April";
                break;
            case Month::May:
                std::cout << "May";
                break;
            case Month::June:
                std::cout << "June";
                break;
            case Month::July:
                std::cout << "July";
                break;
            case Month::August:
                std::cout << "August";
                break;
            case Month::September:
                std::cout << "September";
                break;
            case Month::October:
                std::cout << "October";
                break;
            case Month::Novemver:
                std::cout << "Novemver";
                break;
            case Month::December:
                std::cout << "December";
                break;
            default:
                std::cout << "unknown month";
                break;
        }
    }

    /*
        Âûâîäèò â êîíñîëü
    */
    void print(Month month, DateFormat format = DateFormat::MonthAsInt)
    {
        if (format == DateFormat::MonthAsInt)
        {
            std::cout << static_cast<int>(month);
        }
        else if (format == DateFormat::MonthAsString)
        {
            printMonthAsString(month);
        }
        else
        {
            std::cout << "Wrong format!";
        }
    }

    void print(Date data, DateFormat format = DateFormat::MonthAsInt)
    {
        std::cout << data.day << " ";
        print(data.month, format);
        std::cout << " " << data.year;
    }

    void print(TimeDelta delta) {
        std::cout << delta.delta<< '\n';
    }

    /*
        Âîçâðàùàåò ñåçîí (çèìà, âåñíà, ëåòî, îñåíü) ïåðåäàâàåìîé äàòû
    */
    Season getSeason(Date date) {

        getSeason(date.month);

    }
    Season getSeason(Month month) {

        if (month == Month::December || month == Month::January || month == Month::February)
        {
            return Season::Winter;
        }
        else if (month == Month::March || month == Month::April || month == Month::May)
        {
            return Season::Spring;
        }
        else if (month == Month::June || month == Month::July || month == Month::February)
        {
            return Season::Summer;
        }
        else if (month == Month::September || month == Month::October || month == Month::Novemver)
        {
            return Season::Autumn;
        }

    }

    /*
        Íàïèñàòü ïåðåãðóçêó äëÿ ñëåäóþùèõ ëîãè÷åñêèõ îïåðàòîðîâ
    */
    bool operator == (const Date lhs, const Date rhs) {
        if (lhs.day == rhs.day && lhs.month == rhs.month && lhs.year == rhs.year)
        {
            return true;
        }
        else
        {
            return false;
        }

    }
    bool operator != (const Date lhs, const Date rhs) {
        if (lhs.day != rhs.day && lhs.month != rhs.month && lhs.year != rhs.year)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    bool operator < (const Date lhs, const Date rhs)
    {
        if (lhs.day < rhs.day && lhs.month < rhs.month && lhs.year < rhs.year)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    bool operator <= (const Date lhs, const Date rhs)
    {
        if (lhs.day <= rhs.day && lhs.month <= rhs.month && lhs.year <= rhs.year)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    bool operator > (const Date lhs, const Date rhs)
    {
        if (lhs.day > rhs.day && lhs.month > rhs.month && lhs.year > rhs.year)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    bool operator >= (const Date lhs, const Date rhs)
    {
        if (lhs.day >= rhs.day && lhs.month >= rhs.month && lhs.year >= rhs.year)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /*
        Íàïèñàòü ïåðåãðóçêó äëÿ ñëåäóþùèõ àðèôìåòè÷åñêèõ îïåðàòîðîâ
    */
    Date operator + (const Date date, const TimeDelta delta)
    {
        Date buf;
        buf.day = date.day + delta.delta;
        buf.month = static_cast<int>(date.month) + delta.delta;
        buf.year = date.year + delta.delta;
        return buf;
    }
    Date operator + (const TimeDelta delta, const Date date)
    {
        Date buf;
        buf.day = date.day + delta.delta;
        buf.month = static_cast<int>(date.month) + delta.delta;
        buf.year = date.year + delta.delta;
        return buf;
    }
    TimeDelta operator + (const TimeDelta lhs, const TimeDelta rhs)
    {
        TimeDelta buf;
        buf.delta = lhs.delta + rhs.delta;
        return buf;
    }

    TimeDelta operator * (const TimeDelta delta, int multiplier)
    {
        TimeDelta buf;
        buf.delta = delta.delta * multiplier;
        return buf;
    }
    TimeDelta operator * (int multiplier, const TimeDelta delta)
    {
        TimeDelta buf;
        buf.delta = delta.delta * multiplier;
        return buf;
    }

    /*----------homework-05----------*/

    TimeDelta operator ++ (TimeDelta& delta)

    {
        ++ delta;
        return delta;
    }
    TimeDelta operator ++ (TimeDelta& delta, int)
    {
        TimeDelta& x = delta  ;
        ++x;
        return x;
    }

    TimeDelta operator -- (TimeDelta& delta)
{
    -- delta;
    return delta;
}
    TimeDelta operator -- (TimeDelta& delta, int){
        TimeDelta& x = delta  ;
        --x;
        return x;
    }

    Date operator ++ (Date& delta)
    {
       TimeDelta x ;
       x.delta = 1;
       return delta + x;

    }
    Date operator ++ (Date& delta, int)
    {
        Date x  = delta ;
        delta.year++;

         delta.day++;
        return x ;

    }

    Date operator -- (Date& delta) {
        TimeDelta x ;
        x.delta = 1;
        return delta - x;

    }
    Date operator -- (Date& delta, int){
        Date x  = delta ;
        delta.year--;

        delta.day--;
        return x ;

    }

    /*
        Ìåíÿåò äàòû ìåñòàìè
    */
    void swap(Date& lhs, Date& rhs){
        Date x;
        x = lhs;
        lhs = rhs;
        rhs = x;
    }

    /*
        Ìåíÿåò âðåìåííûå èíòåðâàëû ìåñòàìè
    */
    void swap(TimeDelta& lhs, TimeDelta& rhs){
        TimeDelta x;
        x = lhs;
        lhs = rhs;
        rhs = x;
    }

    /*
        Âîçâðàùàåò ññûëêó íà áîëüøóþ äàòó
    */
    Date& max(Date& lhs, Date& rsh){

        if (lhs > rsh){
            return lhs;
        } else
        {
            return  rsh;
        }
    }

    /*
        Âîçâðàùàåò óêàçàòåëü íà ìåíüøóþ äàòó
    */
    Date& min(Date& lhs, Date& rsh){

        if (lhs < rsh){
            return lhs;
        } else
        {
            return  rsh;
        }
    }


    /*
        Âîçâðàùàåò óêàçàòåëü íà ìèíèìàëüíóþ äàòó â ïåðåäàííîì ìàññèâå äàò
    */
    Date& getMinDate(Date dates[], int size) {

        Date Min;
        Min = dates[0];
        for (int i = 0; i < size; ++i) {
            if (dates[i].year < Min.year && dates[i].month < Min.month && dates[i].day > Min.day)
            {
                 Min.year = dates[i].year;
                Min.month = dates[i].month;
                Min.day = dates[i].day;
            }
        }
        return Min;
    }

    /*
        Âîçâðàùàåò óêàçàòåëü íà ìàêñèìàëüíóþ äàòó â ïåðåäàííîì ìàññèâå äàò
    */
    Date& getMaxDate(Date dates[], int size){

        Date Max;
        for (int i = 0; i < size; ++i) {
            if (dates[i].year > Max.year && dates[i].month < Max.month && dates[i].day > Max.day)
            {
                Max.year = dates[i].year;
                Max.month = dates[i].month;
                Max.day = dates[i].day;
            }
        }
        return Max;
    }

    /*
        Ñîðòèðóåò ìàññèâ äàò ïî óêàçàííîìó êðèòåðèþ
    */
    void sort(Date dates[], SortBy sortBy = SortBy::Date){
        Date x;
        for (int i = 0; i < sizeof(dates) - 1; ++i) {
            for (int j = i; j < sizeof(dates) - 1; ++j) {
                if (countJND(dates[i]).delta > countJND(dates[j]).delta) {
                    x = dates[j];
                    dates[j] = dates[i];
                    dates[i] = x;
                }
            }
        }
    }

    /*
        Ïðîâåðÿåò ìîæåò ëè ñóùåñòâîâàòü äàòà ñ ïåðåäàâàåìûìè çíà÷åíèÿìè.
        Â ñëó÷àå óñïåõà âîçâðàùàåò true, è çàïîëíÿåò äàòó ïî ïåðåäàííîìó àäðåñó.
        Åñëè äàòà ñ ïåðåäàííûìè ïàðàìåòðàìè ñóùåñòâîâàòü íå ìîæåò,
        âîçâðàùàåò ïóñòîé óêàçàòåëü.
    */
    Date* tryFillDate(int year, int month, int day) {
        Date *returnDate;
        if (day <= 28 && day >= 1 && month >= 1 && month <= 12 && year >= 1000 && year <= 3000) {
            cout << "true";
            returnDate->day = day;
            returnDate->month = static_cast<Month>(month);
            returnDate->year = year;
            return returnDate;
        }
        else {
            cout << "false";
            return returnDate;
        }
    }
}
