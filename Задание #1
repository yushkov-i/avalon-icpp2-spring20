#pragma once

#pragma once
#include <iostream>

using namespace std;
namespace ext
{
	enum class Month
	{
		January = 1,
		February = 2,
		March = 3,
		April = 4,
		May = 5,
		June = 6,
		July = 7,
		August = 8,
		September = 9,
		October = 10,
		Novemver = 11,
		December = 12
	};

	enum class DateFormat
	{
		MonthAsInt,
		MonthAsString
	};

	enum class Season
	{
		Winter,
		Spring,
		Summer,
		Autumn
	};

	enum class SortBy
	{
		Date,
		Season
	};

	struct Date
	{
		int year;
		Month month;
		int day;
	};

	struct TimeDelta
	{
		int delta;
	};

	/*----------homework-04----------*/
		/*
			Возвращает Юлианскую дату
			https://ru.wikipedia.org/wiki/%D0%AE%D0%BB%D0%B8%D0%B0%D0%BD%D1%81%D0%BA%D0%B0%D1%8F_%D0%B4%D0%B0%D1%82%D0%B0
			раздел "Вычисление номера юлианского дня (JDN) по дате григорианского календаря"
			Тестовые данные					Ожидаемый результат
			1.12.2018					2458454
			1.1.2018					2458120
			1.6.2000					2451697
			21.12.2012					2456283
		*/
	
	Date Translate_From_JDN(TimeDelta JDN)
	{
		int a = JDN.delta + 32044;
		int b = (4 * a + 3) / 146097;
		int c = a - ((146097 * b) / 4);
		int d = (4 * c + 3) / 1461;
		int e = c - (1461 * d) / 4;
		int m = (5 * e + 2) / 153;

		Date result;

		result.day = e - ((153 * m + 2) / 5) + 1;
		result.month = static_cast<Month>(m + 3 - (12 * (m / 10)));
		result.year = 100 * b + d - 4800 + (m / 10);

		return result;
	}
	
	TimeDelta countJND(Date date)
	{
	   int jdn = 0, a= 0, y = 0, m = 0;

		a = (14 - static_cast<int>(date.month)) / 12;
		y = date.year + 4800 - a;
		m = static_cast<int>(date.month) + 12 * a - 3;

		jdn = date.day + ((153 * m + 1) / 5) + 365 * y + (y / 4) - (y / 100) + (y / 400) - 32045;

		TimeDelta JDN = {jdn};

		return JDN;
	}

	/*
		Рассчитывает количество дней между двумя датами.
		При реализвации используйте CountJND
	*/
	TimeDelta countDistance(Date from, Date to)
	{
		TimeDelta distance;

		distance.delta = countJND(from).delta - countJND(to).delta;

		return distance;
	}


	/*
		Выводит в консоль
	*/
	
	void print(Month month, DateFormat format = DateFormat::MonthAsInt)
	{
		cout << static_cast<int>(month);
	}
	
	void print(Date data, DateFormat format = DateFormat::MonthAsInt)
	{
		cout << data.day << ".";
		print(data.month);
		cout << "." << data.year;
 	}
	
	void print(TimeDelta delta)
	{
		cout << delta.delta;
	}

	/*
		Возвращает сезон (зима, весна, лето, осень) передаваемой даты
	*/
	Season getSeason(Date date)
	{
		Season season;
		
		switch (static_cast<int>(date.month))
		{
		case 1:
		case 2:
		case 12:
			season = static_cast<Season>(0);
			break;
		case 3:
		case 4:
		case 5:
			season = static_cast<Season>(1);
			break;
		case 6:
		case 7:
		case 8:
			season = static_cast<Season>(2);
			break;
		case 9:
		case 10:
		case 11:
			season = static_cast<Season>(3);
	    }
		return season;
	}
	Season getSeason(Month month)
	{
		Date date;
		date.month = month;

		return getSeason(date);
	}

	/*
		Написать перегрузку для следующих логических операторов
	*/
	bool operator == (const Date lhs, const Date rhs)
	{
		return lhs.day == rhs.day && lhs.month == rhs.month && lhs.year == rhs.year;
	}
	bool operator != (const Date lhs, const Date rhs)
	{
		return lhs != rhs;
	}

	bool operator < (const Date lhs, const Date rhs)
	{
		return lhs.day < rhs.day && lhs.month < rhs.month && lhs.year < rhs.year;
	}
	bool operator <= (const Date lhs, const Date rhs)
	{
		return lhs.day <= rhs.day && lhs.month <= rhs.month && lhs.year <= rhs.year;
	}
	bool operator > (const Date lhs, const Date rhs)
	{
		return lhs.day > rhs.day && lhs.month > rhs.month && lhs.year > rhs.year;
	}
	bool operator >= (const Date lhs, const Date rhs)
	{
		return lhs.day >= rhs.day && lhs.month >= rhs.month && lhs.year >= rhs.year;
	}

	/*
		Написать перегрузку для следующих арифметических операторов
	*/
	Date operator + (const Date date, const TimeDelta delta)
	{
		return { date + delta };
	}
	Date operator + (const TimeDelta delta, const Date date)
	{
		return { delta + date };
	}
	TimeDelta operator + (const TimeDelta lhs, const TimeDelta rhs)
	{
		return { lhs.delta + rhs.delta };
	}

	TimeDelta operator * (const TimeDelta delta, int multiplier)
	{
		return { delta.delta * multiplier };
	}
	TimeDelta operator * (int multiplier, const TimeDelta delta)
	{
		return { multiplier * delta.delta };
	}

	/*----------homework-05----------*/

	TimeDelta operator ++ (TimeDelta& delta)
	{
		++delta.delta;
		return delta;
	}
	TimeDelta operator ++ (TimeDelta& delta, int)
	{
		TimeDelta temp = delta;
		++delta;
		return temp;
	}

	TimeDelta operator -- (TimeDelta& delta)
	{
		--delta.delta;
		return delta;
	}
	TimeDelta operator -- (TimeDelta& delta, int)
	{
		TimeDelta temp = delta;
		--delta;
		return temp;
	}

	Date operator ++ (Date& delta)
	{
		TimeDelta temp = countJND(delta);
		++temp;
		return Translate_From_JDN(temp);
	}
	Date operator ++ (Date& delta, int)
	{
		TimeDelta temp = countJND(delta);
		++delta;
		return Translate_From_JDN(temp);
	}
	Date operator -- (Date& delta)
	{
		TimeDelta temp = countJND(delta);
		--temp;
		return Translate_From_JDN(temp);
	}
	Date operator -- (Date& delta, int)
	{
		TimeDelta temp = countJND(delta);
		--delta;
		return Translate_From_JDN(temp);
	}

	/*
		Меняет даты местами
	*/
	void swap(Date& lhs, Date& rhs)
	{
		Date temp = lhs;
		lhs = rhs;
		rhs = temp;
	}

	/*
		Меняет временные интервалы местами
	*/
	void swap(TimeDelta& lhs, TimeDelta& rhs)
	{
		TimeDelta temp = lhs;
		lhs = rhs;
		rhs = temp;
	}

	/*
		Возвращает ссылку на большую дату
	*/
	Date& max(Date& lhs, Date& rhs)
	{
		return lhs > rhs ? lhs : rhs;
	}

	/*
		Возвращает указатель на меньшую дату
	*/
	Date& min(Date& lhs, Date& rhs)
	{
		return lhs < rhs ? lhs : rhs;
	}


	/*
		Сортирует массив дат по указанному критерию
	*/
	void sort(Date dates[], int size)
	{
		for (int i = 0; i < size - 1; i++)
		{
			for (int j = 0; j < size - 1 - i; j++)
			{
				if (dates[j] > dates[j + 1])
				{
					Date swap = dates[j];
					dates[j] = dates[j + 1];
					dates[j + 1] = swap;
				}
			}
		}
	}

	/*
		Возвращает указатель на минимальную дату в переданном массиве дат
	*/
	Date& getMinDate(Date dates[], int size)
	{
		sort(dates, size);
		return dates[0];
	}

	/*
		Возвращает указатель на максимальную дату в переданном массиве дат
	*/
	Date& getMaxDate(Date dates[], int size)
	{
		sort(dates, size);
		return dates[size - 1];
	}

	

	/*
		Проверяет может ли существовать дата с передаваемыми значениями.
		В случае успеха возвращает true, и заполняет дату по переданному адресу.
		Если дата с переданными параметрами существовать не может,
		возвращает пустой указатель.
	*/
	Date* tryFillDate(int year, int month, int day)
	{
		bool exist = false;
		Date* data{0, Month::January, 0};
			
		
		if (year >= 2020)
		{
			if (month % 2 == 1 && month < 8)
			{
				if (day <= 31 && day > 0) exist = true;
			}
			else if (month % 2 == 0 && month < 8)
			{
				if (day <= 30 && day > 0) exist = true;
			}
			else if (month == 2) if (day <= 28 && day > 0) exist = true;
		}

		if (exist)
		{
			cout << "True";
			data->day = day;
			data->month = static_cast<Month>(month);
			data->year = year;
		}
		else cout << "False";
			
		data = nullptr;
		return data;
	}
}
