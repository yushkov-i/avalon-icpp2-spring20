#pragma once
#include <iostream>

namespace ext
{
	enum class Month
	{
		January = 1,
		February,
		March,
		April,
		May,
		June,
		July,
		August,
		September,
		October,
		Novemver,
		December
	};

	enum class DateFormat
	{
		MonthAsInt,
		MonthAsString
	};

	enum class Season
	{
		Winter,
		Spring,
		Summer,
		Autumn
	};

	enum class SortBy
	{
		Date,
		Season
	};

	struct Date
	{
		int year;
		Month month;
		int day;
	};

	struct TimeDelta
	{
		int delta;
	};

	/*----------homework-04----------*/
		/*
			Âîçâðàùàåò Þëèàíñêóþ äàòó
			https://ru.wikipedia.org/wiki/%D0%AE%D0%BB%D0%B8%D0%B0%D0%BD%D1%81%D0%BA%D0%B0%D1%8F_%D0%B4%D0%B0%D1%82%D0%B0
			ðàçäåë "Âû÷èñëåíèå íîìåðà þëèàíñêîãî äíÿ (JDN) ïî äàòå ãðèãîðèàíñêîãî êàëåíäàðÿ"
			Òåñòîâûå äàííûå					Îæèäàåìûé ðåçóëüòàò
			1.12.2018					2458454
			1.1.2018					2458120
			1.6.2000					2451697
			21.12.2012					2456283
		*/
	TimeDelta countJND(Date date) {
		int a, y, m;
		TimeDelta jdn;
		a = (14 - static_cast<int>(date.month)) / 12;
		y = date.year + 4800 - a;
		m = static_cast<int>(date.month) + 12 * a - 3;

		jdn.delta = date.day + ((153 * m + 2) / 5) + 365 * y + y / 4 - y / 100 + y / 400 - 32045;
		return jdn;
	}

	/*
		Ðàññ÷èòûâàåò êîëè÷åñòâî äíåé ìåæäó äâóìÿ äàòàìè.
		Ïðè ðåàëèçâàöèè èñïîëüçóéòå CountJND
	*/
	TimeDelta countDistance(Date from, Date to);

	void printMonthAsString(Month month)
	{
		switch (month)
		{
		case Month::January:
			std::cout << "january";
			break;
		case Month::February:
			std::cout << "february";
			break;
		case Month::March:
			std::cout << "march";
			break;
		case Month::April:
			std::cout << "April";
			break;
		case Month::May:
			std::cout << "May";
			break;
		case Month::June:
			std::cout << "June";
			break;
		case Month::July:
			std::cout << "July";
			break;
		case Month::August:
			std::cout << "August";
			break;
		case Month::September:
			std::cout << "September";
			break;
		case Month::October:
			std::cout << "October";
			break;
		case Month::Novemver:
			std::cout << "Novemver";
			break;
		case Month::December:
			std::cout << "December";
			break;
		default:
			std::cout << "unknown month";
			break;
		}
	}

	/*
		Âûâîäèò â êîíñîëü
	*/
	void print(Month month, DateFormat format = DateFormat::MonthAsInt)
	{
		if (format == DateFormat::MonthAsInt)
		{
			std::cout << static_cast<int>(month);
		}
		else if (format == DateFormat::MonthAsString)
		{
			printMonthAsString(month);
		}
		else
		{
			std::cout << "Wrong format!";
		}
	}

	void print(Date data, DateFormat format = DateFormat::MonthAsInt)
	{
		std::cout << data.day << " ";
		print(data.month, format);
		std::cout << " " << data.year;
	}

	void print(TimeDelta delta) {
		std::cout << delta.delta<< '\n';
	}

	/*
		Âîçâðàùàåò ñåçîí (çèìà, âåñíà, ëåòî, îñåíü) ïåðåäàâàåìîé äàòû
	*/
	Season getSeason(Date date) {

		getSeason(date.month);

	}
	Season getSeason(Month month) {
		
		if (month == Month::December || month == Month::January || month == Month::February)
		{			 
			return Season::Winter;
		}
		else if (month == Month::March || month == Month::April || month == Month::May)
		{
			return Season::Spring;
		}
		else if (month == Month::June || month == Month::July || month == Month::February)
		{
			return Season::Summer;
		}
		else if (month == Month::September || month == Month::October || month == Month::Novemver)
		{
			return Season::Autumn;
		}

	}

	/*
		Íàïèñàòü ïåðåãðóçêó äëÿ ñëåäóþùèõ ëîãè÷åñêèõ îïåðàòîðîâ
	*/
	bool operator == (const Date lhs, const Date rhs) {
		if (lhs.day == rhs.day && lhs.month == rhs.month && lhs.year == rhs.year)
		{
			return true;
		}
		else
		{
			return false;
		}

	}
	bool operator != (const Date lhs, const Date rhs) {
		if (lhs.day != rhs.day && lhs.month != rhs.month && lhs.year != rhs.year)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool operator < (const Date lhs, const Date rhs)
	{
		if (lhs.day < rhs.day && lhs.month < rhs.month && lhs.year < rhs.year)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool operator <= (const Date lhs, const Date rhs)
	{
		if (lhs.day <= rhs.day && lhs.month <= rhs.month && lhs.year <= rhs.year)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool operator > (const Date lhs, const Date rhs)
	{
		if (lhs.day > rhs.day && lhs.month > rhs.month && lhs.year > rhs.year)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool operator >= (const Date lhs, const Date rhs)
	{
		if (lhs.day >= rhs.day && lhs.month >= rhs.month && lhs.year >= rhs.year)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	/*
		Íàïèñàòü ïåðåãðóçêó äëÿ ñëåäóþùèõ àðèôìåòè÷åñêèõ îïåðàòîðîâ
	*/
	Date operator + (const Date date, const TimeDelta delta) 
	{
		Date buf;
		buf.day = date.day + delta.delta;
		buf.month = static_cast<int>(date.month) + delta.delta;
		buf.year = date.year + delta.delta;
		return buf;
	}
	Date operator + (const TimeDelta delta, const Date date)
	{
		Date buf;
		buf.day = date.day + delta.delta;
		buf.month = static_cast<int>(date.month) + delta.delta;
		buf.year = date.year + delta.delta;
		return buf;
	}
	TimeDelta operator + (const TimeDelta lhs, const TimeDelta rhs)
	{
		TimeDelta buf;
		buf.delta = lhs.delta + rhs.delta;
		return buf;
	}

	TimeDelta operator * (const TimeDelta delta, int multiplier)
	{
		TimeDelta buf;
		buf.delta = delta.delta * multiplier;
		return buf;
	}
	TimeDelta operator * (int multiplier, const TimeDelta delta)
	{
		TimeDelta buf;
		buf.delta = delta.delta * multiplier;
		return buf;
	}

	/*----------homework-05----------*/

	TimeDelta operator ++ (TimeDelta& delta);
	TimeDelta operator ++ (TimeDelta& delta, int);

	TimeDelta operator -- (TimeDelta& delta);
	TimeDelta operator -- (TimeDelta& delta, int);

	Date operator ++ (Date& delta);
	Date operator ++ (Date& delta, int);

	Date operator -- (Date& delta);
	Date operator -- (Date& delta, int);

	/*
		Ìåíÿåò äàòû ìåñòàìè
	*/
	void swap(Date& lhs, Date& rhs);

	/*
		Ìåíÿåò âðåìåííûå èíòåðâàëû ìåñòàìè
	*/
	void swap(TimeDelta& lhs, TimeDelta& rhs);

	/*
		Âîçâðàùàåò ññûëêó íà áîëüøóþ äàòó
	*/
	Date& max(Date& lhs, Date& rsh);

	/*
		Âîçâðàùàåò óêàçàòåëü íà ìåíüøóþ äàòó
	*/
	Date& min(Date& lhs, Date& rsh);

	/*
		Âîçâðàùàåò óêàçàòåëü íà ìèíèìàëüíóþ äàòó â ïåðåäàííîì ìàññèâå äàò
	*/
	Date& getMinDate(Date dates[], int size);

	/*
		Âîçâðàùàåò óêàçàòåëü íà ìàêñèìàëüíóþ äàòó â ïåðåäàííîì ìàññèâå äàò
	*/
	Date& getMaxDate(Date dates[], int size);

	/*
		Ñîðòèðóåò ìàññèâ äàò ïî óêàçàííîìó êðèòåðèþ
	*/
	void sort(Date dates[], SortBy sortBy = SortBy::Date);

	/*
		Ïðîâåðÿåò ìîæåò ëè ñóùåñòâîâàòü äàòà ñ ïåðåäàâàåìûìè çíà÷åíèÿìè.
		Â ñëó÷àå óñïåõà âîçâðàùàåò true, è çàïîëíÿåò äàòó ïî ïåðåäàííîìó àäðåñó.
		Åñëè äàòà ñ ïåðåäàííûìè ïàðàìåòðàìè ñóùåñòâîâàòü íå ìîæåò,
		âîçâðàùàåò ïóñòîé óêàçàòåëü.
	*/
	Date* tryFillDate(int year, int month, int day);
}
